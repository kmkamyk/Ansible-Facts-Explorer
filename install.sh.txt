#!/bin/bash
set -euo pipefail

# ==============================================================================
# Ansible Facts Explorer (AFE) Installation Script v2.5 for RHEL-based Systems
# ==============================================================================
# This script automates the deployment of the AFE application, including:
# - A dedicated PostgreSQL database with a randomly generated password.
# - The Node.js API backend as a systemd service with interactive setup.
# - An Nginx reverse proxy with automated firewall and port conflict resolution.
# - Fixes for common permissions and SELinux issues (403 Forbidden).
# - Full uninstall capability for clean removal.
#
# See README.md for detailed usage instructions.
# ==============================================================================

# --- Configuration Variables ---
FRONTEND_DIR="/app/afe"
BACKEND_DIR="/data/afe-api"
PGDATA="/var/lib/pgsql/15/data" # Default for RHEL/PostgreSQL 15 module
PGUSER="afeuser"
PGDB="afedb"
ENV_FILE="/etc/afe-api.env"
SERVICE_FILE="/etc/systemd/system/afe-api.service"
NGINX_CONF="/etc/nginx/conf.d/afe.conf"

# --- Helper Functions for Logging ---
log_info() {
  echo -e "\033[0;32m[INFO]\033[0m $1"
}

log_warn() {
  echo -e "\033[0;33m[WARN]\033[0m $1" >&2
}

log_error() {
  echo -e "\033[0;31m[ERROR]\033[0m $1" >&2
}

# --- Utility Functions ---
function get_available_port() {
  local port=80
  # Use ss to check if port 80 is actively listening. The regex ensures we don't match '8080'.
  if ss -tln | grep -qP ':(80)\s'; then
      port=8080
      log_warn "Port 80 is already in use. AFE will be configured on port 8080."
  fi
  echo "$port"
}

# --- Pre-flight Checks ---
function run_checks() {
    log_info "Running pre-flight checks..."
    local dependencies=("dnf" "systemctl" "npm" "node" "rsync" "sudo" "ss" "sestatus" "chcon")
    local missing_deps=0
    for cmd in "${dependencies[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            log_error "Dependency missing: '$cmd'. Please install it and try again."
            missing_deps=1
        fi
    done
    if [[ $missing_deps -eq 1 ]]; then
        exit 1
    fi
    log_info "All dependencies are present."
}

# --- Installation Functions ---

function deploy_frontend() {
  log_info "Deploying AFE frontend..."

  if [[ ! -d "dist" ]]; then
     log_error "Frontend build directory 'dist' not found. Please build the frontend first:"
     log_error "  npm install && npm run build"
     exit 1
  fi
  
  log_info "Syncing built files from 'dist/' to $FRONTEND_DIR..."
  # The directory should already be created by the 'nginx' or 'all' step
  rsync -a --delete dist/ "$FRONTEND_DIR/"
  chown -R nginx:nginx "$FRONTEND_DIR"

  # Re-apply SELinux context after copying new files to prevent 403 errors
  if sestatus | grep -q "Current mode:.*enforcing"; then
    log_info "SELinux is enforcing. Re-applying 'httpd_sys_content_t' context to new frontend files..."
    chcon -R -t httpd_sys_content_t "$FRONTEND_DIR" || log_warn "Failed to set SELinux context."
  fi

  if systemctl is-active --quiet nginx; then
    log_info "Reloading Nginx to apply changes..."
    nginx -t && systemctl reload nginx
  fi

  log_info "Frontend deployed successfully to $FRONTEND_DIR"
}

function deploy_backend() {
  log_info "Deploying AFE backend..."
  
  local PGPASSWORD=$1

  # Create a non-login system user for the service
  if ! id "afeapi" &>/dev/null; then
    log_info "Creating system user 'afeapi'..."
    useradd -r -s /usr/sbin/nologin afeapi
  fi

  log_info "Syncing backend files to $BACKEND_DIR..."
  if [[ ! -d "fact-api-backend" ]]; then
      log_error "Backend directory 'fact-api-backend' not found. Please ensure it exists."
      exit 1
  fi
  mkdir -p "$BACKEND_DIR"
  rsync -a --delete fact-api-backend/ "$BACKEND_DIR/"
  chown -R afeapi:afeapi "$BACKEND_DIR"

  log_info "Installing backend dependencies as user 'afeapi'..."
  # Use 'npm install' as it's more robust than 'npm ci' for this scenario.
  # Explicitly set cache dir to avoid permission errors with system users that have no home dir.
  sudo -u afeapi npm install --prefix "$BACKEND_DIR" --cache "$BACKEND_DIR/.npm-cache" --no-audit --omit=dev

  log_info "Configuring environment file at $ENV_FILE..."
  
  local AWX_URL=""
  local AWX_TOKEN=""
  
  # Interactive prompts for critical settings
  read -p "Enter your AWX instance URL (e.g., https://awx.example.com): " AWX_URL
  read -sp "Enter your AWX API Token: " AWX_TOKEN
  echo

  tee "$ENV_FILE" >/dev/null <<EOF
# --- Node.js Environment ---
NODE_ENV=production
PORT=4000

# --- Database Configuration ---
DB_HOST=localhost
DB_PORT=5432
DB_USER=$PGUSER
DB_PASSWORD=$PGPASSWORD
DB_NAME=$PGDB

# --- AWX Configuration ---
AWX_URL=${AWX_URL}
AWX_TOKEN=${AWX_TOKEN}
AWX_CONCURRENCY_LIMIT=20
AWX_REQUEST_TIMEOUT=30000
EOF
  chmod 600 "$ENV_FILE"
  chown root:afeapi "$ENV_FILE"

  log_info "Creating systemd service file at $SERVICE_FILE..."
  tee "$SERVICE_FILE" >/dev/null <<EOF
[Unit]
Description=AFE API backend (Node.js)
Documentation=https://github.com/kmkamyk/ansible-facts-explorer
After=network.target postgresql.service

[Service]
Type=simple
User=afeapi
Group=afeapi
WorkingDirectory=$BACKEND_DIR
EnvironmentFile=$ENV_FILE
ExecStart=/usr/bin/node $BACKEND_DIR/server.js
Restart=on-failure
RestartSec=10
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
EOF

  log_info "Reloading systemd, enabling and starting afe-api.service..."
  systemctl daemon-reload
  systemctl enable --now afe-api.service
  
  sleep 2
  systemctl status afe-api.service --no-pager

  log_info "Backend deployed to $BACKEND_DIR and running on port 4000."
}

function install_postgres() {
  log_info "Installing and configuring PostgreSQL..."
  
  # Generate a secure password for the database user
  local PGPASSWORD
  PGPASSWORD=$(openssl rand -base64 16)

  log_info "Installing PostgreSQL 15..."
  dnf -y module enable postgresql:15
  dnf install -y postgresql-server postgresql

  if [ ! -d "$PGDATA/base" ]; then
    log_info "Initializing PostgreSQL database at $PGDATA..."
    /usr/bin/postgresql-setup --initdb
  else
    log_warn "PostgreSQL data directory already exists. Skipping initialization."
  fi
  
  log_info "Enabling and starting the postgresql service..."
  systemctl enable --now postgresql

  log_info "Configuring database '$PGDB' and user '$PGUSER'..."
  # Use `sudo -i -u` to ensure commands run in the postgres user's home directory context
  sudo -i -u postgres -- psql -c "SELECT 1 FROM pg_roles WHERE rolname='$PGUSER'" | grep -q 1 || sudo -i -u postgres -- psql -c "CREATE ROLE $PGUSER WITH LOGIN PASSWORD '$PGPASSWORD';"
  sudo -i -u postgres -- psql -lqt | cut -d \| -f 1 | grep -qw "$PGDB" || sudo -i -u postgres -- psql -c "CREATE DATABASE $PGDB OWNER $PGUSER;"
  
  sudo -i -u postgres -- psql -d "$PGDB" -c "GRANT ALL PRIVILEGES ON DATABASE $PGDB TO $PGUSER;"

  log_info "Creating the 'facts' table if it doesn't exist..."
  sudo -i -u postgres -- psql -d "$PGDB" <<SQL
CREATE TABLE IF NOT EXISTS facts (
    id SERIAL PRIMARY KEY,
    hostname VARCHAR(255) UNIQUE NOT NULL,
    data JSONB NOT NULL,
    modified_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE facts OWNER TO $PGUSER;
SQL

  log_info "PostgreSQL installed and configured successfully."
  # Return the generated password for use in other functions
  echo "$PGPASSWORD"
}

function configure_nginx() {
  log_info "Installing and configuring Nginx..."
  
  local NGINX_PORT=$1

  dnf install -y nginx
  systemctl enable --now nginx

  # --- CRITICAL FIX 1: Disable default site in conf.d ---
  if [[ -f /etc/nginx/conf.d/default.conf ]]; then
    log_warn "Found default Nginx configuration in conf.d. Renaming to 'default.conf.bak' to prevent conflicts."
    mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.bak
  fi

  # --- CRITICAL FIX 2: Disable default server block in nginx.conf for newer systems ---
  # Check if the default welcome page is configured and active inside the main config file
  if grep -qP '^\s*root\s+/usr/share/nginx/html;' /etc/nginx/nginx.conf; then
      log_warn "Found active default server block in /etc/nginx/nginx.conf. Attempting to disable it."
      local root_line_num start_line end_line end_line_relative
      
      # Find the line number of the specific root directive that identifies the default server block
      root_line_num=$(grep -n "/usr/share/nginx/html" /etc/nginx/nginx.conf | head -n1 | cut -d: -f1)
      
      if [[ -n "$root_line_num" ]]; then
          # Find the line number of the 'server {' that BEGINS the block containing our root directive
          start_line=$(head -n "$root_line_num" /etc/nginx/nginx.conf | grep -n "^\s*server\s*{" | tail -n1 | cut -d: -f1)
          # Find the relative line number of the '}' that ENDS the block
          end_line_relative=$(tail -n +$start_line /etc/nginx/nginx.conf | grep -n "^\s*}" | head -n1 | cut -d: -f1)
          
          if [[ -n "$start_line" && -n "$end_line_relative" ]]; then
              # Convert the relative end line number to an absolute one
              end_line=$((start_line + end_line_relative - 1))
              
              if [[ "$end_line" -ge "$start_line" ]]; then
                  log_info "Commenting out default server block from line $start_line to $end_line."
                  sed -i.bak "$start_line,${end_line}s/^/#/" /etc/nginx/nginx.conf
                  log_info "A backup of nginx.conf was created at /etc/nginx/nginx.conf.bak"
              else
                  log_warn "Could not reliably determine the end of the server block. Skipping automatic commenting."
              fi
          else
              log_warn "Could not reliably determine the boundaries of the default server block. Skipping."
              log_warn "You may need to manually comment out the default server block in /etc/nginx/nginx.conf."
          fi
      fi
  fi

  # Create the webroot directory *before* configuring Nginx to use it.
  log_info "Ensuring frontend directory exists at $FRONTEND_DIR..."
  mkdir -p "$FRONTEND_DIR"
  chown nginx:nginx "$FRONTEND_DIR"

  # --- CRITICAL FIX 3: Set correct permissions and SELinux context to prevent 403 Forbidden ---
  # The Nginx user needs execute permission on all parent directories.
  # /app is the parent, and might have been created with restrictive permissions by root.
  log_info "Setting correct traversal permissions for /app directory..."
  chmod 755 /app

  # If SELinux is enforcing, Nginx cannot read files without the correct context.
  if sestatus | grep -q "Current mode:.*enforcing"; then
    log_info "SELinux is enforcing. Applying 'httpd_sys_content_t' context to $FRONTEND_DIR..."
    # 'chcon' applies the context now. For persistence across reboots, 'semanage' would be needed,
    # but chcon is sufficient for this script's scope and more universally available.
    chcon -R -t httpd_sys_content_t "$FRONTEND_DIR" || log_warn "Failed to set SELinux context. This may cause 403 errors."
  fi

  log_info "Creating Nginx configuration at $NGINX_CONF for port ${NGINX_PORT}..."
  tee "$NGINX_CONF" >/dev/null <<EOF
server {
    # Make this the default server for this port to avoid conflicts
    listen ${NGINX_PORT} default_server;
    server_name _; # Listens on all hostnames

    root $FRONTEND_DIR;
    index index.html;

    # Serve static files for the React app
    location / {
        try_files \$uri \$uri/ /index.html;
    }

    # Proxy API requests to the backend Node.js server
    location /api/ {
        # The trailing slash on the location but NOT on the proxy_pass
        # ensures that a request to /api/facts is forwarded as /api/facts.
        proxy_pass http://127.0.0.1:4000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }
}
EOF
  
  if systemctl is-active --quiet firewalld; then
    log_info "Firewalld is active. Adding rule for port ${NGINX_PORT}/tcp..."
    firewall-cmd --permanent --add-port=${NGINX_PORT}/tcp
    firewall-cmd --reload
  fi

  log_info "Testing and reloading Nginx configuration..."
  nginx -t && systemctl reload nginx
  log_info "Nginx configured with frontend at $FRONTEND_DIR, backend proxy, and listening on port ${NGINX_PORT}."
}

function uninstall_app() {
    log_warn "This will permanently delete the AFE application and its data."
    read -p "Are you sure you want to continue? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Uninstall cancelled."
        exit 0
    fi

    log_info "Stopping and disabling services..."
    systemctl stop afe-api.service nginx || true
    systemctl disable afe-api.service || true

    if systemctl is-active --quiet firewalld; then
        local NGINX_PORT
        if [[ -f "$NGINX_CONF" ]]; then
            # Reliably determine the port from the config file before deleting it
            NGINX_PORT=$(grep -oP 'listen\s+\K[0-9]+' "$NGINX_CONF" || echo "80")
            log_info "Removing firewall rule for port ${NGINX_PORT}/tcp..."
            if firewall-cmd --query-port=${NGINX_PORT}/tcp --permanent; then
                firewall-cmd --permanent --remove-port=${NGINX_PORT}/tcp
                firewall-cmd --reload
            else
                log_warn "Firewall rule for port ${NGINX_PORT}/tcp not found. Skipping."
            fi
        else
             log_warn "Nginx config not found. Could not determine port to remove from firewall."
        fi
    fi

    log_info "Removing files and directories..."
    rm -f "$SERVICE_FILE"
    rm -f "$NGINX_CONF"
    rm -f "$ENV_FILE"
    rm -rf "$FRONTEND_DIR"
    rm -rf "$BACKEND_DIR"

    log_info "Reloading systemd daemon..."
    systemctl daemon-reload

    read -p "Do you also want to remove the PostgreSQL user and database? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_info "Dropping database '$PGDB' and user '$PGUSER'..."
        sudo -i -u postgres -- psql -c "DROP DATABASE IF EXISTS $PGDB;"
        sudo -i -u postgres -- psql -c "DROP ROLE IF EXISTS $PGUSER;"
    else
        log_warn "PostgreSQL data was not removed."
    fi

    log_info "Uninstall complete."
}

function show_status() {
    log_info "Checking status of AFE services..."
    echo "--- Nginx Status ---"
    systemctl status nginx --no-pager
    echo
    echo "--- AFE API Backend Status ---"
    systemctl status afe-api.service --no-pager
    echo
    log_info "To check PostgreSQL, run: sudo systemctl status postgresql"
}

### MAIN SCRIPT LOGIC ###
if [[ $EUID -ne 0 ]]; then
   log_error "This script must be run as root (or with sudo)." 
   exit 1
fi

if [[ $# -ne 1 ]]; then
  echo "Usage: $0 [frontend|backend|postgres|nginx|all|uninstall|status]"
  echo "  all:       Runs postgres, nginx, and backend installers."
  echo "  frontend:  Deploys the pre-built React frontend from the 'dist' directory."
  echo "  backend:   Deploys the Node.js backend service (requires DB password)."
  echo "  postgres:  Installs and configures PostgreSQL."
  echo "  nginx:     Installs and configures Nginx."
  echo "  uninstall: Removes all AFE components from the system."
  echo "  status:    Checks the status of AFE services."
  exit 1
fi

run_checks

case "$1" in
  all)
    log_info "Running 'all' tasks: postgres, nginx, backend..."
    GENERATED_PGPASSWORD=$(install_postgres)
    USED_NGINX_PORT=$(get_available_port)
    configure_nginx "$USED_NGINX_PORT"
    deploy_backend "$GENERATED_PGPASSWORD"
    
    echo -e "\n\033[1;32m========================= INSTALLATION SUMMARY ========================="
    log_info "All backend services deployed successfully."
    log_info "Nginx Port:           $USED_NGINX_PORT (Access the app at http://<your_ip>:${USED_NGINX_PORT})"
    log_info "Database User:        $PGUSER"
    log_info "Database Name:        $PGDB"
    log_warn "Generated DB Password:  $GENERATED_PGPASSWORD (Please save this password securely!)"
    log_info "Frontend Location:    $FRONTEND_DIR"
    log_info "Backend Location:     $BACKEND_DIR"
    log_info "Environment File:     $ENV_FILE"
    log_info "Next Step: Remember to build and deploy the frontend using:"
    log_info "  npm install && npm run build"
    log_info "  sudo $0 frontend"
    echo -e "\033[1;32m======================================================================\033[0m"
    ;;
  frontend)
    deploy_frontend
    ;;
  backend)
    log_error "The 'backend' command cannot be run standalone due to password generation."
    log_error "Please use the 'all' command to install the full backend stack."
    exit 1
    ;;
  postgres)
    install_postgres
    ;;
  nginx)
    USED_NGINX_PORT=$(get_available_port)
    configure_nginx "$USED_NGINX_PORT"
    ;;
  uninstall)
    uninstall_app
    ;;
  status)
    show_status
    ;;
  *)
    log_error "Invalid option: $1"
    echo "Usage: $0 [frontend|backend|postgres|nginx|all|uninstall|status]"
    exit 1
    ;;
esac

log_info "Script finished."
