#!/bin/bash
set -euo pipefail

# ==============================================================================
# Ansible Facts Explorer (AFE) Installation Script v3.7 for RHEL-based Systems
# ==============================================================================
# This script automates the deployment of the AFE application, including:
# - A dedicated PostgreSQL database using the default system version.
# - The Node.js API backend as a systemd service with dynamic configuration.
# - An Nginx reverse proxy configured for HTTPS with self-signed certificates.
# - Interactive prompts for required configuration (AWX URL, Token, Ollama).
# - Full uninstall capability for clean removal.
#
# See README.md for detailed usage instructions.
# ==============================================================================

# --- Configuration Variables ---
# These will be set interactively or generated by the script
PGPASSWORD=""
AWX_URL=""
AWX_TOKEN=""
OLLAMA_URL=""
OLLAMA_MODEL=""
OLLAMA_EMBEDDING_MODEL=""
OLLAMA_API_FORMAT=""
USE_AI_SEARCH_FLAG="false"
# --- End of user configuration ---

FRONTEND_DIR="/app/afe"
BACKEND_DIR="/data/afe-api"
PGDATA="/var/lib/pgsql/data" # Default data directory for PostgreSQL
PGUSER="afeuser"
PGDB="afedb"
SERVICE_FILE="/etc/systemd/system/afe-api.service"
NGINX_CONF="/etc/nginx/conf.d/afe.conf"
SSL_KEY="/etc/ssl/private/afe.key"
SSL_CERT="/etc/ssl/certs/afe.crt"

# --- Helper Functions for Logging ---
log_info() {
  echo -e "\033[0;32m[INFO]\033[0m $1"
}

log_warn() {
  echo -e "\033[0;33m[WARN]\033[0m $1" >&2
}

log_error() {
  echo -e "\033[0;31m[ERROR]\033[0m $1" >&2
}

# --- Pre-flight Checks ---
function run_checks() {
    log_info "Running pre-flight checks..."
    local dependencies=("dnf" "systemctl" "npm" "node" "rsync" "sudo" "ss" "sestatus" "chcon" "openssl" "setsebool")
    local missing_deps=0
    for cmd in "${dependencies[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            log_error "Dependency missing: '$cmd'. Please install it and try again."
            missing_deps=1
        fi
    done
    if [[ $missing_deps -eq 1 ]]; then
        exit 1
    fi
    log_info "All dependencies are present."
}

# --- Interactive Setup for Credentials ---
function interactive_setup() {
    log_info "Starting interactive setup for backend configuration..."

    # Prompt for PostgreSQL password
    local PGPASSWORD_CONFIRM
    read -sp "Enter a password for the new database user '$PGUSER' (will not be displayed): " PGPASSWORD
    echo
    if [[ -z "$PGPASSWORD" ]]; then
        log_error "Database password cannot be empty."
        exit 1
    fi
    read -sp "Confirm the password: " PGPASSWORD_CONFIRM
    echo
    if [[ "$PGPASSWORD" != "$PGPASSWORD_CONFIRM" ]]; then
        log_error "Passwords do not match. Aborting."
        exit 1
    fi
    log_info "Database password has been set."

    # Prompt for AWX URL
    read -p "Enter your AWX instance URL (e.g., https://awx.example.com): " AWX_URL
    if [[ -z "$AWX_URL" ]]; then
        log_error "AWX URL cannot be empty."
        exit 1
    fi

    # Prompt for AWX Token
    read -sp "Enter your AWX token (will not be displayed): " AWX_TOKEN
    echo
    if [[ -z "$AWX_TOKEN" ]]; then
        log_error "AWX Token cannot be empty."
        exit 1
    fi

    # Prompt to enable AI
    local ENABLE_AI
    read -p "Enable AI search feature (requires configured Ollama)? [y/N]: " ENABLE_AI
    if [[ "$ENABLE_AI" =~ ^[Yy]$ ]]; then
        USE_AI_SEARCH_FLAG="true"
        log_info "AI search feature has been enabled. Now collecting Ollama details."
        # Prompt for Ollama URL
        read -p "Enter your Ollama API URL [http://127.0.0.1:11434]: " OLLAMA_URL
        OLLAMA_URL=${OLLAMA_URL:-"http://127.0.0.1:11434"} # Set default if empty

        # Prompt for Ollama Model
        read -p "Enter the Ollama model to use for generation [llama3.1]: " OLLAMA_MODEL
        OLLAMA_MODEL=${OLLAMA_MODEL:-"llama3.1"} # Set default if empty

        # Prompt for Ollama Embedding Model
        read -p "Enter the Ollama model to use for embeddings [nomic-embed-text]: " OLLAMA_EMBEDDING_MODEL
        OLLAMA_EMBEDDING_MODEL=${OLLAMA_EMBEDDING_MODEL:-"nomic-embed-text"} # Set default if empty
        
        # Prompt for API Format
        read -p "Enter the AI API format (ollama or openai for llama.cpp) [ollama]: " OLLAMA_API_FORMAT
        OLLAMA_API_FORMAT=${OLLAMA_API_FORMAT:-"ollama"}
    else
        log_info "AI search feature is disabled."
    fi

    log_info "Configuration details collected."
}


# --- Installation Functions ---
function generate_ssl_certs() {
  log_info "Checking for SSL certificates..."
  if [[ -f "$SSL_KEY" && -f "$SSL_CERT" ]]; then
    log_info "SSL certificates already exist. Skipping generation."
  else
    log_warn "SSL certificates not found. Generating self-signed certificates for Nginx..."
    mkdir -p /etc/ssl/certs /etc/ssl/private
    openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
      -keyout "$SSL_KEY" \
      -out "$SSL_CERT" \
      -subj "/CN=localhost"
    log_info "Self-signed certificates generated."
  fi
}

function deploy_frontend() {
  log_info "Deploying AFE frontend..."

  if [[ ! -d "dist" ]]; then
     log_error "Frontend build directory 'dist' not found. Please build the frontend first:"
     log_error "  npm install && npm run build"
     exit 1
  fi
  
  log_info "Syncing built files from 'dist/' to $FRONTEND_DIR..."
  rsync -a --delete dist/ "$FRONTEND_DIR/"
  chown -R nginx:nginx "$FRONTEND_DIR"

  if sestatus | grep -q "Current mode:.*enforcing"; then
    log_info "SELinux is enforcing. Re-applying 'httpd_sys_content_t' context to new frontend files..."
    chcon -R -t httpd_sys_content_t "$FRONTEND_DIR" || log_warn "Failed to set SELinux context."
  fi

  if systemctl is-active --quiet nginx; then
    log_info "Reloading Nginx to apply changes..."
    nginx -t && systemctl reload nginx
  fi

  log_info "Frontend deployed successfully to $FRONTEND_DIR"
}

function deploy_backend() {
  log_info "Deploying AFE backend..."
  
  if ! id "afeapi" &>/dev/null; then
    log_info "Creating system user 'afeapi'..."
    useradd -r -s /usr/sbin/nologin afeapi
  fi

  log_info "Syncing backend files to $BACKEND_DIR..."
  if [[ ! -d "fact-api-backend" ]]; then
      log_error "Backend directory 'fact-api-backend' not found. Please ensure it exists."
      exit 1
  fi
  mkdir -p "$BACKEND_DIR"
  rsync -a --delete fact-api-backend/ "$BACKEND_DIR/"
  chown -R afeapi:afeapi "$BACKEND_DIR"

  log_info "Installing backend dependencies as user 'afeapi'..."
  sudo -u afeapi npm install --prefix "$BACKEND_DIR" --cache "$BACKEND_DIR/.npm-cache" --no-audit --omit=dev

  log_info "Creating backend configuration file at $BACKEND_DIR/config.js..."
  # This overwrites the development config.js that was copied.
  # The backend is configured for HTTP as it sits behind an HTTPS Nginx proxy.
  tee "$BACKEND_DIR/config.js" >/dev/null <<EOF
// config.js - This file is auto-generated by the install.sh script.
// It contains the production configuration for the AFE backend.

const dbConfig = {
  host: 'localhost',
  port: 5432,
  user: '$PGUSER',
  password: '$PGPASSWORD',
  database: '$PGDB',
};

const awxConfig = {
  url: '$AWX_URL',
  token: '$AWX_TOKEN',
  concurrencyLimit: 20,
  requestTimeout: 30000,
};

const ollamaConfig = {
  url: '$OLLAMA_URL',
  model: '$OLLAMA_MODEL',
  embeddingModel: '$OLLAMA_EMBEDDING_MODEL',
  useAiSearch: $USE_AI_SEARCH_FLAG,
  apiFormat: '$OLLAMA_API_FORMAT',
  systemPromptTemplate: 'You are a helpful AI assistant that converts natural language queries into structured search filters for a tool called Ansible Facts Explorer. Your task is to generate a JSON array of strings, where each string is a search filter pill.\\n\\n' +
    'The available fact paths for searching are:\\n' +
    '\\\${allFactPaths}\\n\\n' +
    'The supported filter syntax is:\\n' +
    '- "some text": for a simple regex/substring search across all fields.\\n' +
    '- ""exact text"": for an exact match on a field\\'s value.\\n' +
    '- "key=value": for an exact match on a fact path ending with \\'key\\' and having the value \\'value\\'.\\n' +
    '- "key>value", "key<value", "key>=value", "key<=value": for numerical comparisons.\\n' +
    '- "key!=value": for non-equality checks.\\n' +
    '- "term1|term2": for an OR condition within a single filter pill.\\n\\n' +
    'Rules:\\n' +
    '- You MUST respond with ONLY a valid JSON array of strings. Do not add any explanation, preamble, or markdown formatting.\\n' +
    '- If a user\\'s query asks for a fact but provides no value (e.g., "show me cpu counts", "what kernel versions"), return only the fact path. Do NOT append an "=" sign.\\n' +
    '- If a user\\'s query provides a specific value or comparison (e.g., "4 cpus", "distribution is ubuntu"), use the appropriate syntax like "key=value" or "key>value".\\n' +
    '- Analyze the query to create the most specific and accurate filter pills. Break complex queries into multiple pills.\\n\\n' +
    'Here are some examples:\\n' +
    'input: "ubuntu hosts with 4 cpus"\\n' +
    'output: ["distribution=Ubuntu", "vcpus=4"]\\n\\n' +
    'input: "what are the cpu counts?"\\n' +
    'output: ["ansible_processor_vcpus"]',
  userPromptTemplate: 'User Query: "\\\${prompt}"\\n\\nYour JSON Response:',
  chatSystemPromptTemplate: \`You are a helpful and knowledgeable AI assistant for a tool called Ansible Facts Explorer.
Your task is to answer the user's question based ONLY on the provided "Context" which contains relevant Ansible facts for a set of hosts retrieved from a larger database.

Follow these rules strictly:
1.  Base all your answers on the provided "Context". Do not use any external knowledge or make assumptions.
2.  The context is a snippet of the most relevant data. If the answer is not in the "Context", state that you cannot find the information in the relevant facts you were given. Do not suggest the information might exist elsewhere.
3.  Be concise and provide direct answers.
4.  You can use Markdown for formatting (like lists or bold text) to improve readability.

----------------
CONTEXT:
{context}
----------------

QUESTION: {question}

ANSWER:\`,
};

const sslConfig = {
  keyPath: '',
  certPath: '',
  caPath: '',
};

module.exports = {
  dbConfig,
  awxConfig,
  sslConfig,
  ollamaConfig,
};
EOF
  chown afeapi:afeapi "$BACKEND_DIR/config.js"
  chmod 640 "$BACKEND_DIR/config.js"

  log_info "Creating systemd service file at $SERVICE_FILE..."
  tee "$SERVICE_FILE" >/dev/null <<EOF
[Unit]
Description=AFE API backend (Node.js)
Documentation=https://github.com/kmkamyk/ansible-facts-explorer
After=network.target postgresql.service

[Service]
Type=simple
User=afeapi
Group=afeapi
WorkingDirectory=$BACKEND_DIR
# Allows connecting to AWX with self-signed certificates.
Environment="NODE_TLS_REJECT_UNAUTHORIZED=0"
# Configuration is loaded from $BACKEND_DIR/config.js by the application
ExecStart=/usr/bin/node $BACKEND_DIR/server.js
Restart=on-failure
RestartSec=10
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
EOF

  log_info "Reloading systemd, enabling and starting afe-api.service..."
  systemctl daemon-reload
  systemctl enable --now afe-api.service
  
  sleep 2
  systemctl status afe-api.service --no-pager

  log_info "Backend deployed to $BACKEND_DIR and running on port 4000 (HTTP)."
}

function install_postgres() {
  log_info "Installing and configuring PostgreSQL from default repositories..."

  log_info "Installing PostgreSQL server..."
  dnf install -y postgresql-server

  if [ ! -d "$PGDATA/base" ]; then
    log_info "Initializing PostgreSQL database at $PGDATA..."
    # Use the standard setup script for the default package, usually in /usr/bin
    if command -v postgresql-setup &>/dev/null; then
        /usr/bin/postgresql-setup --initdb
    else
        log_error "postgresql-setup script not found. Cannot initialize the database cluster."
        log_error "Please initialize the PostgreSQL database manually."
        exit 1
    fi
  else
    log_warn "PostgreSQL data directory already exists. Skipping initialization."
  fi
  
  log_info "Enabling and starting the postgresql service..."
  systemctl enable --now postgresql

  log_info "Configuring database '$PGDB' and user '$PGUSER'..."
  sudo -i -u postgres -- psql -c "SELECT 1 FROM pg_roles WHERE rolname='$PGUSER'" | grep -q 1 || sudo -i -u postgres -- psql -c "CREATE ROLE $PGUSER WITH LOGIN PASSWORD '$PGPASSWORD';"
  sudo -i -u postgres -- psql -lqt | cut -d \| -f 1 | grep -qw "$PGDB" || sudo -i -u postgres -- psql -c "CREATE DATABASE $PGDB OWNER $PGUSER;"
  
  sudo -i -u postgres -- psql -d "$PGDB" -c "GRANT ALL PRIVILEGES ON DATABASE $PGDB TO $PGUSER;"

  log_info "Configuring PostgreSQL to allow password authentication for local connections..."
  PG_HBA_CONF="$PGDATA/pg_hba.conf"
  if [ -f "$PG_HBA_CONF" ]; then
    if ! grep -q "$PG_HBA_CONF.bak" "$PG_HBA_CONF.bak" &>/dev/null; then
        log_info "Backing up pg_hba.conf to $PG_HBA_CONF.bak"
        cp "$PG_HBA_CONF" "$PG_HBA_CONF.bak"
    fi
    
    # This is the key change:
    # - We leave 'local' connections as 'peer' so that script-based admin actions (like this one) work without a password.
    # - We change 'host' connections (TCP/IP, even to localhost) from 'ident' to 'scram-sha-256' so that psql/apps can connect with a password.
    log_info "Updating pg_hba.conf to use 'scram-sha-256' for password authentication on host connections..."
    sed -i -E "s/^(host\s+all\s+all\s+127\.0\.0\.1\/32\s+)ident$/\1scram-sha-256/" "$PG_HBA_CONF"
    sed -i -E "s/^(host\s+all\s+all\s+::1\/128\s+)ident$/\1scram-sha-256/" "$PG_HBA_CONF"

    log_info "Reloading PostgreSQL to apply authentication changes..."
    systemctl reload postgresql
  else
    log_warn "Could not find pg_hba.conf at $PG_HBA_CONF. Manual configuration may be required to enable password authentication."
  fi

  log_info "Creating the 'facts' table if it doesn't exist..."
  sudo -i -u postgres -- psql -d "$PGDB" <<SQL
CREATE TABLE IF NOT EXISTS facts (
    id SERIAL PRIMARY KEY,
    hostname VARCHAR(255) UNIQUE NOT NULL,
    data JSONB NOT NULL,
    modified_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE facts OWNER TO $PGUSER;
SQL

  log_info "PostgreSQL installed and configured successfully."
}

function configure_nginx() {
  log_info "Installing and configuring Nginx for HTTPS..."

  dnf install -y nginx
  systemctl enable --now nginx

  if [[ -f /etc/nginx/conf.d/default.conf ]]; then
    log_warn "Found default Nginx configuration in conf.d. Renaming to 'default.conf.bak'."
    mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.bak
  fi

  if [[ -f /etc/nginx/nginx.conf.bak ]]; then
    log_info "Restoring main Nginx configuration from backup to undo previous changes."
    mv /etc/nginx/nginx.conf.bak /etc/nginx/nginx.conf
  fi

  log_info "Ensuring frontend directory exists at $FRONTEND_DIR..."
  mkdir -p "$FRONTEND_DIR"
  chown nginx:nginx "$FRONTEND_DIR"

  log_info "Setting correct traversal permissions and SELinux context..."
  chmod 755 /app
  if sestatus | grep -q "Current mode:.*enforcing"; then
    chcon -R -t httpd_sys_content_t "$FRONTEND_DIR" || log_warn "Failed to set SELinux context."
    log_info "SELinux is enforcing. Allowing Nginx to make network connections for proxying..."
    setsebool -P httpd_can_network_connect 1 || log_warn "Failed to set SELinux boolean 'httpd_can_network_connect'. Proxying to backend may fail."
  fi

  log_info "Creating Nginx configuration at $NGINX_CONF for HTTPS..."
  tee "$NGINX_CONF" >/dev/null <<EOF
# Redirect all HTTP traffic to HTTPS
server {
    listen 80 default_server;
    server_name _;
    return 301 https://\$host\$request_uri;
}

# Main HTTPS server block
server {
    listen 443 ssl http2 default_server;
    server_name _;

    # Increase max body size to allow large fact lists for AI search
    client_max_body_size 16m;

    # SSL Configuration (uses self-signed certs generated by this script)
    ssl_certificate $SSL_CERT;
    ssl_certificate_key $SSL_KEY;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;

    root $FRONTEND_DIR;
    index index.html;

    location / {
        try_files \$uri \$uri/ /index.html;
    }

    # Proxy API requests to the HTTP backend Node.js server
    location /api/ {
        proxy_pass http://127.0.0.1:4000;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # Increase timeouts for long-running API calls like fetching AWX facts
        proxy_connect_timeout 300s;
        proxy_send_timeout    300s;
        proxy_read_timeout    300s;
    }
}
EOF
  
  if systemctl is-active --quiet firewalld; then
    log_info "Firewalld is active. Adding rules for HTTP and HTTPS services..."
    firewall-cmd --permanent --add-service=http
    firewall-cmd --permanent --add-service=https
    firewall-cmd --reload
  fi

  log_info "Testing and reloading Nginx configuration..."
  nginx -t && systemctl reload nginx
  log_info "Nginx configured for HTTPS on port 443."
}

function uninstall_app() {
    log_warn "This will permanently delete the AFE application and its data."
    read -p "Are you sure you want to continue? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Uninstall cancelled."
        exit 0
    fi

    log_info "Stopping and disabling services..."
    systemctl stop afe-api.service nginx postgresql || log_warn "Could not stop all services (they may not be running)."
    systemctl disable afe-api.service postgresql || log_warn "Could not disable all services."

    if systemctl is-active --quiet firewalld; then
        log_info "Removing firewall rules for HTTP and HTTPS..."
        firewall-cmd --permanent --remove-service=http >/dev/null 2>&1 || true
        firewall-cmd --permanent --remove-service=https >/dev/null 2>&1 || true
        firewall-cmd --reload
    fi

    log_info "Removing application files and directories..."
    rm -f "$SERVICE_FILE" "$NGINX_CONF" "$SSL_KEY" "$SSL_CERT"
    rm -rf "$FRONTEND_DIR" "$BACKEND_DIR"
    
    if [[ -f /etc/nginx/conf.d/default.conf.bak ]]; then
      log_info "Restoring default Nginx conf.d configuration..."
      mv /etc/nginx/conf.d/default.conf.bak /etc/nginx/conf.d/default.conf
    fi
    if [[ -f /etc/nginx/nginx.conf.bak ]]; then
      log_info "Restoring main Nginx configuration..."
      mv /etc/nginx/nginx.conf.bak /etc/nginx/nginx.conf
    fi

    log_info "Removing system user 'afeapi'..."
    if id "afeapi" &>/dev/null; then
        userdel afeapi
        log_info "User 'afeapi' removed."
    else
        log_warn "User 'afeapi' not found."
    fi

    log_info "Reloading systemd daemon and nginx..."
    systemctl daemon-reload
    nginx -t && systemctl reload nginx || log_warn "Nginx could not be reloaded. A restart may be required."

    read -p "Do you also want to remove the PostgreSQL user and database? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_info "Dropping database '$PGDB' and user '$PGUSER'..."
        if systemctl is-active --quiet postgresql; then
            sudo -i -u postgres -- psql -c "DROP DATABASE IF EXISTS $PGDB;" || log_warn "Failed to drop database '$PGDB'."
            sudo -i -u postgres -- psql -c "DROP ROLE IF EXISTS $PGUSER;" || log_warn "Failed to drop role '$PGUSER'."
        else
            log_warn "PostgreSQL is not running. Cannot drop database and user automatically."
        fi
    else
        log_warn "PostgreSQL database and user were not removed."
    fi

    read -p "Do you want to COMPLETELY UNINSTALL PostgreSQL and DELETE all its data? This cannot be undone. [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_warn "Proceeding with complete PostgreSQL removal..."
        systemctl stop postgresql || log_warn "PostgreSQL was not running."
        systemctl disable postgresql || log_warn "Could not disable PostgreSQL."
        log_info "Removing PostgreSQL packages..."
        dnf remove -y 'postgresql-server' > /dev/null
        log_info "Deleting PostgreSQL data directory $PGDATA..."
        rm -rf "$PGDATA"
        log_warn "PostgreSQL and all its data have been removed."
    else
        log_warn "PostgreSQL package was not removed."
    fi

    log_info "Uninstall complete."
}

function show_status() {
    log_info "Checking status of AFE services..."
    echo "--- Nginx Status ---"
    systemctl status nginx --no-pager
    echo
    echo "--- AFE API Backend Status ---"
    systemctl status afe-api.service --no-pager
    echo
    echo "--- PostgreSQL Status ---"
    systemctl status postgresql --no-pager
}

### MAIN SCRIPT LOGIC ###
if [[ $EUID -ne 0 ]]; then
   log_error "This script must be run as root (or with sudo)." 
   exit 1
fi

if [[ $# -ne 1 ]]; then
  echo "Usage: $0 [frontend|postgres|nginx|all|uninstall|status]"
  echo "  all:       Installs postgres, generates certs, configures nginx & backend, and deploys the frontend."
  echo "  frontend:  Deploys the pre-built React frontend from the 'dist' directory."
  echo "  postgres:  Installs and configures PostgreSQL."
  echo "  nginx:     Installs and configures Nginx for HTTPS."
  echo "  uninstall: Removes all AFE components from the system."
  echo "  status:    Checks the status of AFE services."
  exit 1
fi

run_checks

case "$1" in
  all)
    log_info "Running 'all' tasks: interactive setup, postgres, certs, nginx, backend, and frontend..."
    interactive_setup
    install_postgres
    generate_ssl_certs
    configure_nginx
    deploy_backend

    log_info "Building frontend application..."
    if ! (npm install && npm run build); then
        log_error "Frontend build failed. Please check for errors in the output above."
        log_error "You may need to resolve frontend issues and then run 'sudo $0 frontend' manually."
        exit 1
    fi
    log_info "Frontend build successful. Deploying..."
    deploy_frontend
    
    echo -e "\n\033[1;32m========================= INSTALLATION COMPLETE ========================="
    log_info "All services deployed successfully."
    log_info "App URL:              https://<your_server_ip>"
    log_info "Database User:        $PGUSER"
    log_info "Database Password:    (the one you provided during setup)"
    log_warn "!!! IMPORTANT: Remember the password. It is needed for manual database access. !!!"
    log_info "AWX URL configured:   $AWX_URL"
    log_info "AI Search Enabled:    $USE_AI_SEARCH_FLAG"
    if [[ "$USE_AI_SEARCH_FLAG" == "true" ]]; then
      log_info "Ollama URL:           $OLLAMA_URL"
      log_info "Ollama Gen Model:     $OLLAMA_MODEL"
      log_info "Ollama Embed Model:   $OLLAMA_EMBEDDING_MODEL"
      log_info "AI API Format:        $OLLAMA_API_FORMAT"
    fi
    log_info "Backend config file:  $BACKEND_DIR/config.js"
    log_info "You can now access the application at the URL above."
    echo -e "\033[1;32m======================================================================\033[0m"
    ;;
  frontend)
    deploy_frontend
    ;;
  postgres)
    log_warn "The 'postgres' command is intended for debugging. For a full install, use 'all'."
    interactive_setup
    install_postgres
    log_warn "PostgreSQL has been configured with the password you provided."
    ;;
  nginx)
    generate_ssl_certs # Nginx needs certs to start correctly
    configure_nginx
    ;;
  uninstall)
    uninstall_app
    ;;
  status)
    show_status
    ;;
  *)
    log_error "Invalid option: $1"
    echo "Usage: $0 [frontend|postgres|nginx|all|uninstall|status]"
    exit 1
    ;;
esac

log_info "Script finished."